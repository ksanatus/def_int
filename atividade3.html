
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nouislider@14.7.0/distribute/nouislider.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.0.0/math.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link href="https://cdn.jsdelivr.net/npm/nouislider@14.7.0/distribute/nouislider.min.css" rel="stylesheet">

<style>
    body {
        font-family: 'Roboto', sans-serif;
        background-color: #f4f7fc;
        display: flex;
        justify-content: flex-start;  
        padding: 40px;
        margin: 0;
        flex-wrap: nowrap;  
    }

    h2 {
        font-size: 2.5rem;
        color: #0056b3;
        margin-bottom: 30px;
        text-align: center;
    }

    #sidebar {
        width: 350px;
        padding: 25px;
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        margin-right: 30px;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
    }

    button {
        background-color: #007bff;
        color: white;
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 18px;
    }

    button:hover {
        background-color: #0056b3;
    }

    #main-content {
        display: flex;
        flex-direction: row;
        flex-grow: 1;  
    }

    #graph {
        margin-top: 30px;
        margin-left: 0;
        margin-right: 150px;
    }

    #integralValues {
        font-size: 14px;
        line-height: 1.5;
        margin-top: 25px;
        text-align: center;
        background-color: #ffffff;
        padding: 10px;
        border-radius: 12px;
        box-shadow: 0 6px 16px rgba(0,0,0,0.1);
        max-width: 320px;
        height: auto;
        max-height: 200px;
        overflow: hidden;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

    .integral-info {
        margin-bottom: 10px;
        font-size: 16px;
        font-weight: 500;
    }

    .blue {
        color: #1e90ff;
    }

    .message {
        font-size: 18px;
        font-weight: bold;
        margin-top: 20px;
    }

    .slider-container {
    margin-bottom: 20px;
    width: 100%;  /* Garantir que o slider ocupe todo o espaço disponível */
    }

    .slider-container label {
        font-size: 14px;
        color: #333;
        display: block;  /* Garantir que o label ocupe toda a linha */
    }

    .slider-container span {
        font-size: 18px;
        font-weight: bold;
        display: inline-block;
        margin-top: 10px;
    }

    .slider-container #xSlider, .slider-container #hSlider {
    width: 100%; /* Garantir que os sliders tenham 100% de largura disponível */
    }
</style>

<!-- Conteúdo -->
<div id="sidebar">
    <div>
        <label for="functionInput">Digite a função f(x) (exemplo: x^2):</label>
        <input type="text" id="functionInput" value="x^2">
        <button onclick="updateFunction()">Atualizar Função</button>
    </div>
    <div id="sliders">
        <!-- Slider para o valor de x -->
        <div class="slider-container">
            <label for="xSlider">Limite inferior x:</label>
            <span id="xValue">1</span><br>
            <div id="xSlider"></div>
        </div>
        <!-- Slider para o valor de h -->
        <div class="slider-container">
            <label for="hSlider">Valor de h:</label>
            <span id="hValue">2</span><br> <!-- Defina um valor inicial para hValue -->
            <div id="hSlider"></div>
        </div>
    </div>
</div>

<div id="main-content">
    <div id="graph"></div>
</div>

<script>
    // Função para calcular a integral definida no intervalo [x, x+h]
    function integralNumerica(func, x, h, n = 10000) {
        if (h < 0.0001) { 
            return func(x);  // Aproximação de f(x) para h muito pequeno
        }

        let step = h / n;
        let sum = 0;
        for (let i = 0; i < n; i++) {
            sum += func(x + i * step) * step;
        }
        return sum;
    }

    let x = 1, h = 2;
    let funcString = "x^2"; 
    let f = math.parse(funcString).compile(); 

    // Atualizar a função a partir do input do usuário
    function updateFunction() {
        funcString = document.getElementById('functionInput').value;

            f = math.parse(funcString).compile(); 
            updateGraphs();

    }

    // Função para avaliar a função
    function evaluateFunction(x) {
        return f.evaluate({ x: x });
    }

    // Função para calcular a reta tangente
    function tangente(x, f) {
        let y = f(x); // f(x0)
        let derivative = math.derivative(funcString, 'x'); // Derivada de f(x)
        let fPrime = derivative.evaluate({ x: x }); // f'(x0)

        // Equação da reta tangente: y = f'(x0) * (x - x0) + f(x0)
        let tangenteX = [x - 2, x - 1, x, x + 1, x + 2]; // Estendendo a reta para o lado esquerdo e direito
        let tangenteY = tangenteX.map(xi => fPrime * (xi - x) + y); // Calculando y para os valores de x

        return { tangenteX, tangenteY };
    }

    // Função para calcular a reta secante
    function secante(x, h, f) {
        let y1 = f(x);
        let y2 = f(x + h);

        // Cálculo da inclinação
        let m = (y2 - y1) / h;

        // Pontos da reta secante
        let extendedX = [x - 1, x, x + h, x + h + 1];
        let extendedY = extendedX.map(xi => m * (xi - x) + y1);  // Equação da reta secante: y = m * (x - x1) + y1

        return { secanteX: extendedX, secanteY: extendedY, m };  // Retorna os pontos estendidos da reta
    }

    // Atualizar gráficos e cálculos
    function updateGraphs() {
        let integralValue = integralNumerica(evaluateFunction, x, h);

        let xValues = [];
        let fValues = [];
        for (let i = 0; i <= 10; i += 0.1) {
            xValues.push(i);
            fValues.push(evaluateFunction(i));
        }

        let trace1 = {
            x: xValues,
            y: fValues,
            type: 'scatter',
            mode: 'lines',
            name: 'f(x)',
            line: { color: "#007bff" }
        };

        let layout1 = {
            xaxis: {
                title: 'x',
                range: [0, 12]
            },
            yaxis: {
                title: 'f(x)'
            },
            width: 1000,
            height: 600,
            margin: {
                r: 100,
                t: 50,
                b: 50,
                l: 50
            },
            legend: {
                x: 0.8,
                y: 1,
                traceorder: 'normal',
                orientation: 'v',
                xanchor: 'left',
                yanchor: 'top',
                overflow: 'visible'
            }
        };

        let areaTrace = {};
        if (h > 0) {
            let numSteps = 1000;
            let stepSize = h / numSteps;
            let areaX = [];
            let areaY = [];
            for (let i = 0; i <= numSteps; i++) {
                let xi = x + i * stepSize;
                areaX.push(xi);
                areaY.push(Math.max(0, evaluateFunction(xi)));
            }

            areaTrace = {
                x: areaX,
                y: areaY,
                fill: 'tozeroy',
                type: 'scatter',
                fillcolor: 'rgba(0, 123, 255, 0.3)',
                line: { color: 'rgba(0, 123, 255, 0.3)' },
                showlegend: false
            };
        }

        let dashedLines = [];
        let xLine1 = { x: [x, x], y: [0, evaluateFunction(x)], line: { color: 'black', dash: 'dash' }, showlegend: false };
        let xLine2 = { x: [x + h, x + h], y: [0, evaluateFunction(x + h)], line: { color: 'black', dash: 'dash' }, showlegend: false };
        dashedLines.push(xLine1, xLine2);

        let secanteTrace = null;
        if (h > 0) {
            let secanteLine = secante(x, h, evaluateFunction);
            secanteTrace = {
                x: secanteLine.secanteX,
                y: secanteLine.secanteY,
                type: 'scatter',
                mode: 'lines',
                name: `Reta Secante (m = ${secanteLine.m.toFixed(2)})`,
                line: { color: 'red', dash: 'dot' }
            };
        } else {
            let tangenteLine = tangente(x, evaluateFunction);
            secanteTrace = {
                x: tangenteLine.tangenteX,
                y: tangenteLine.tangenteY,
                type: 'scatter',
                mode: 'lines',
                name: 'Reta Tangente',
                line: { color: 'green', dash: 'solid' }
            };
        }

        Plotly.react('graph', [trace1, areaTrace, ...dashedLines, secanteTrace], layout1);


        MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.body]);
    }

    window.onload = function() {
        // Inicialização do slider de x
        let xSlider = document.getElementById('xSlider');
        let xValueDisplay = document.getElementById('xValue');
        noUiSlider.create(xSlider, {
            start: x,
            range: { 'min': 0, 'max': 10 },
            step: 0.1
        });
        xSlider.noUiSlider.on('update', function(values) {
            x = parseFloat(values[0]);
            xValueDisplay.innerHTML = x.toFixed(2);
            updateGraphs();
        });

        // Inicialização do slider de h
        let hSlider = document.getElementById('hSlider');
        let hValueDisplay = document.getElementById('hValue');
        noUiSlider.create(hSlider, {
            start: h,
            range: { 'min': 0, 'max': 10 },
            step: 0.1
        });
        hSlider.noUiSlider.on('update', function(values) {
            h = parseFloat(values[0]);
            hValueDisplay.innerHTML = h.toFixed(2);
            updateGraphs();
        });

        updateGraphs(); // Atualizar gráficos na inicialização
    };
</script>
